package de.sikora.androidapp_alertclient;

import android.util.Log;

import java.io.InputStream;
import java.io.OutputStream;

import java.net.InetAddress;
import java.net.Socket;
import java.net.UnknownHostException;

import java.io.IOException;

import java.util.LinkedList;
import java.util.concurrent.atomic.AtomicBoolean;

/**
 * Connects to an alert device and performs the communication with the device.
 *
 * Network tasks are performed within the run method.
 *
 */
public class AlertClientTcp implements Runnable, AlertDeviceModel.AlertStateListener {

    // Value that is sent to the server to read the current alert level
    static final int CMD_READ_REQUEST = 3;

    // Value that is sent to the server to read the device id
    static final int CMD_ID_REQUEST = 4;

    // Length of a device id in bytes
    static final int ID_NUM_BYTES = 6;

    // Sleep time after connection failure
    private static final long TIME_SLEEP_AFTER_CON_FAILURE = 5000;

    // Sleep time after performing network input/output over the socket
    private static final long TIME_SLEEP_AFTER_IO = 100;

    // Time after which the client sends a read request to the server
    private static final long TIME_READ_REQUEST_CYCLE = 2500;

    // Time after which the server should respond after a read request
    private static final long TIME_READ_RESPONSE_MAX = 1000;

    // Number of failed server responses at which the connection is considered broken
    private static final int NUM_FAILED_RESPONSES_MAX = 3;

    // Tag for log messages generated by this class
    private static final String TAG = AlertClientTcp.class.getSimpleName();

    // Representation of the alert server that this client connects to
    private AlertDeviceModel alertDevice;

    // Message queue: values to be sent to the server
    private final LinkedList<Integer> alertOutputBuffer = new LinkedList<>();

    // Thread in which the run() method of the AlertClientTcp object is executed
    private Thread alertClientThread = null;

    // Flag that is used to stop the run() method
    private boolean runClient;

    // Flag that is used to prevent multiple threads to run concurrently
    private final AtomicBoolean alertClientBusy = new AtomicBoolean(false);

    // Client socket for communicating with the Alert Server
    private Socket alertSocket = null;

    // Output stream to Alert Server
    private OutputStream alertOut = null;

    // Input stream from Alert Server
    private InputStream alertIn = null;

    // Timestamp of last request to the server
    private long lastReadRequestTime;

    // Flag if client is waiting for a response from server
    private boolean waitingForResponse = false;

    // Number of failed responses from the server
    private int numFailedResponses = 0;


    /**
     * Creates an AlertClientTcp object and registers itself as a listener to the provided
     * AlertDeviceModel object.
     *
     * When AlertDeviceModel sends an AlertLevelEvent of the type ALERT_LEVEL_EVENT, AlertClientTcp
     * sends the new alert level to the alert device in order to set the requested alert level.
     *
     * When the alert device sends an alert level to the client, AlertClientTcp notifies the
     * listeners that have registered to the AlertDeviceModel.
     *
     * @param alertDevice AlertDeviceModel containing the IP address or name and port of the alert
     *                    device.
     */
    public AlertClientTcp(AlertDeviceModel alertDevice) {
        this.alertDevice = alertDevice;
    }

    public boolean isRunning() {
        return runClient;
    }

    /**
     * Sends the message entered by client to the server
     *
     * @param alertLevel Alert level to be sent to the Alert Server.
     */
    private void writeAlertLevel(final int alertLevel) {
        synchronized (alertOutputBuffer) {
            alertOutputBuffer.addLast(alertLevel);
        }
    }

    /**
     * Enqueues a request to be sent to the server to read the current alert level
     */
    private void requestAlertLevel() {
        synchronized (alertOutputBuffer) {
            alertOutputBuffer.addLast(CMD_READ_REQUEST);
        }
    }

    public AlertDeviceModel getAlertDevice() {
        return alertDevice;
    }

    /**
     * Close the connection and release the members
     */
    public void shutdown() {
        String tagExt;

        try {
            tagExt = TAG + "@" + Thread.currentThread().getId();
        }
        catch (Exception e) {
            tagExt = TAG + "@null";
        }

        Log.i(tagExt, "Shutdown started.");

        // Tell the run method to stop
        runClient = false;

        // Interrupt the thread in case it is sleeping
        if (alertClientThread != null) {
            alertClientThread.interrupt();
        }

        // Clear the output queue
        synchronized (alertOutputBuffer) {
            alertOutputBuffer.clear();
        }
    }

    /**
     * Connects to the specified alert device.
     *
     * @return True, if successfully connected to the alert device.
     */
    private boolean connect() {
        String tagExt;

        try {
            tagExt = TAG + "@" + Thread.currentThread().getId();
        }
        catch (Exception e) {
            tagExt = TAG + "@null";
        }

        // If a previous socket exists try to close it
        disconnect();

        InetAddress serverAddr;

        try {
            Log.i( tagExt, "Trying to connect to Alert Server " + alertDevice.getAddress()
                    + ":" + alertDevice.getPort() );

            // Create InetAddress to connect to
            serverAddr = InetAddress.getByName(alertDevice.getAddress());

            // Create a socket and connect to the Alert Server using the specified address and port
            alertSocket = new Socket(serverAddr, alertDevice.getPort());

            Log.i( tagExt, "Connected to Alert Server. Local address: "
                    + alertSocket.getLocalAddress() + ":" + alertSocket.getLocalPort()
                    + ", Remote address: " + alertSocket.getRemoteSocketAddress() );

            // Get input stream from server
            alertIn = alertSocket.getInputStream();

            // Get output stream to server
            alertOut = alertSocket.getOutputStream();

            // Set the flag indicating the a connection is established
            alertDevice.setConnectedAndNotify(true, this);
        }
        catch (UnknownHostException e) {
            Log.i(tagExt, "Could not find Alert Server.");

            alertSocket = null;
            alertOut = null;
            alertIn = null;

            alertDevice.setConnectedAndNotify(false, this);
        }
        catch (IOException e) {
            Log.i(tagExt, "Could not connect to Alert Server.");

            alertSocket = null;
            alertOut = null;
            alertIn = null;

            alertDevice.setConnectedAndNotify(false, this);
        }

        // Return connection state
        return alertDevice.isConnected();
    }

    private void disconnect() {
        String tagExt;

        try {
            tagExt = TAG + "@" + Thread.currentThread().getId();
        }
        catch (Exception e) {
            tagExt = TAG + "@null";
        }

        // If a previous socket exists try to close it
        if (alertSocket != null  && !alertSocket.isClosed()) {
            try {
                alertSocket.close();
            }
            catch (IOException e) {
                // Failed to close
            }
            finally {
                Log.i(tagExt, "Socket closed.");

                alertSocket = null;
                alertOut = null;
                alertIn = null;

                waitingForResponse = false;
                numFailedResponses = 0;

                alertDevice.setConnectedAndNotify(false, this);
            }
        }
    }

    /**
     * Performs the network tasks associated with the alert device.
     */
    public void run() {
        // Set Thread priority to background
        android.os.Process.setThreadPriority(android.os.Process.THREAD_PRIORITY_BACKGROUND);

        String tagExt;

        try {
            tagExt = TAG + "@" + Thread.currentThread().getId();
        }
        catch (Exception e) {
            tagExt = TAG + "@null";
        }

        Log.i(tagExt, "Start run(): Checking busy flag.");

        // While this runnable is active let the thread wait until the previous thread runs out
        while ( !alertClientBusy.compareAndSet(false, true) ) {
            Log.w(tagExt, "Start run(): Busy. Calling wait().");
            try {
                synchronized (alertClientBusy) {
                    alertClientBusy.wait();
                }
            } catch (InterruptedException e) {
                // Wakeup from sleep
            }
        }

        Log.i(tagExt, "Start run(): Initialization.");

        // Store the current Thread so that the shutdown method can interrupt it
        alertClientThread = Thread.currentThread();

        // Add this object as listener of the alert device object
        this.alertDevice.addListener(this);

        try {
            runClient = true;

            // Repeat as long as the alertClientActive flag is true:
            // 1. Connect to server
            // 2. Communicate with server until connection is lost
            while (runClient) {

                boolean connectOk = false;

                // Connect to Alert Server if possible
                while (!connectOk && runClient) {
                    connectOk = connect();

                    // In case of a connection failure wait for some time before next try
                    if (!connectOk) {
                        try {
                            Thread.sleep(TIME_SLEEP_AFTER_CON_FAILURE);
                        } catch (InterruptedException e) {
                            // Wakeup from sleep
                        }
                    }
                }

                // Handle the communication with the server
                try {

                    while (runClient && alertSocket.isConnected()) {

                        /* --- 1. Receive --- */

                        // Determine time since last message exchange with server
                        long curTime = System.currentTimeMillis();
                        long passedTimeReq = curTime - lastReadRequestTime;

                        // Number of input values in input buffer
                        int numRxAvailable = alertIn.available();

                        // Process next value received from the server
                        if (numRxAvailable > 0) {
                            Log.i(tagExt, "Rx bytes available: '" + numRxAvailable);

                            int rxValue = alertIn.read();

                            if (waitingForResponse) {
                                Log.i(tagExt, "Received '" + rxValue + "' from server ("
                                                + passedTimeReq + " ms).");
                            }
                            else {
                                Log.i(tagExt, "Received '" + rxValue + "' from server.");
                            }

                            // Reset flag and fail counter in case a response has been due
                            waitingForResponse = false;
                            numFailedResponses = 0;

                            // Update the alert state
                            alertDevice.setAlertLevelAndNotify(rxValue, this);
                        }
                        else {
                            // Check if response is overdue
                            if (waitingForResponse && passedTimeReq > TIME_READ_RESPONSE_MAX) {
                                waitingForResponse = false;
                                numFailedResponses += 1;

                                Log.i(tagExt, "Alert server failed to respond (count = "
                                        + numFailedResponses + ").");

                                // Raise an exception in case of too many failures
                                if (numFailedResponses >= NUM_FAILED_RESPONSES_MAX) {

                                    // Reset the flag and counter
                                    waitingForResponse = false;
                                    numFailedResponses = 0;

                                    throw new IOException("Exceeded maximum number of failed server responses.");
                                }
                            }
                        }

                        /* --- 2. Send --- */

                        boolean isTxValue = false;
                        int txValue = Integer.MAX_VALUE;

                        // Obtain lock for output buffer and take next value
                        synchronized (alertOutputBuffer) {
                            if (!alertOutputBuffer.isEmpty()) {
                                txValue = alertOutputBuffer.removeFirst();
                                isTxValue = true;
                            }
                        }

                        // Send the output value to the Alert Server
                        if (isTxValue) {
                            Log.i(tagExt, "Sending '" + txValue + "' to server.");

                            alertOut.write(txValue);
                            alertOut.flush();
                        }
                        else {
                            // In case there is no value to be sent, insert a read request to the
                            // server in order to:
                            // 1. Test the connection periodically
                            // 2. Keep the client synchronized (just in case something goes wrong)
                            if (passedTimeReq > TIME_READ_REQUEST_CYCLE) {

                                Log.i(tagExt, "Sending read request (value = "
                                        + CMD_READ_REQUEST + ") to server.");

                                alertOut.write(CMD_READ_REQUEST);
                                alertOut.flush();

                                // Set timestamp and flag in order to monitor the response
                                lastReadRequestTime = curTime;
                                waitingForResponse = true;
                            }
                        }

                        /* --- 3. Pause --- */

                        // Pause the thread for some time after doing input/output
                        try {
                            Thread.sleep(TIME_SLEEP_AFTER_IO);
                        } catch (InterruptedException e) {
                            // Wakeup from sleep
                        }
                    }
                }
                catch (IOException e) {
                    Log.i(tagExt, "Communication failure.", e);
                }
                finally {
                    // Close the socket before leaving this block
                    disconnect();
                }
            }

        }
        catch (Exception e) {
            Log.e(tagExt, "Unexpected failure.", e);
        }
        finally {
            // Set run flag to false in case the loop ended due to a failure
            runClient = false;

            // Clean everything up before leaving the run() method
            Log.i(tagExt, "Stopping the alert client.");

            // Remove this object as listener from the alert device object
            alertDevice.removeListener(this);

            // If there is still a connection close it
            disconnect();

            Log.i(tagExt, "Finishing run()");

            // Set the stored Thread of AlertClientTcp to null
            alertClientThread = null;

            // Set busy flag to false to allow other threads to enter the run method
            synchronized (alertClientBusy) {
                alertClientBusy.set(false);
                alertClientBusy.notify();
            }
        }
    }

    /**
     * This method is called when an alert level is received from the server.
     *
     * @param alertState AlertDeviceModel containing the current alert state provided by the
     *                   alert server.
     * @param ev         AlertStateEvent containing the type  and source of the event.
     */
    @Override
    public void onAlertLevelEvent(AlertDeviceModel alertState, AlertDeviceModel.AlertStateEvent ev) {
        writeAlertLevel(alertState.getAlertLevel());
    }

    /**
     * This method is called when the state of the connection between this client and the alert
     * server changes.
     *
     * @param alertState AlertDeviceModel containing the current connection state, i.e. whether
     *                   this client is connected to the alert server.
     * @param ev         AlertStateEvent containing the type  and source of the event.
     */
    @Override
    public void onConnectionStateEvent(AlertDeviceModel alertState, AlertDeviceModel.AlertStateEvent ev) {

    }
}