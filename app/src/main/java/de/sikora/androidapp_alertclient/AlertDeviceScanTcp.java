package de.sikora.androidapp_alertclient;

import android.util.Log;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.InetAddress;
import java.net.InetSocketAddress;
import java.net.Socket;
import java.net.SocketAddress;
import java.net.SocketTimeoutException;
import java.net.UnknownHostException;
import java.util.LinkedList;
import java.util.List;
import java.util.concurrent.atomic.AtomicBoolean;

public class AlertDeviceScanTcp implements Runnable {

    // Tag for log messages generated by this class
    private static final String TAG = AlertDeviceScanTcp.class.getSimpleName();

    // Connection timeout in ms
    private static final int TIME_CONNECT_MAX = 200;

    // Address of the local network that shall be scanned
    private String networkAdrStr;

    // Address of the first node that shall be scanned
    private int nodeAdrFirst;

    // Address of the last node that shall be scanned
    private int nodeAdrLast;

    // Port number of the remote port
    private int alertRemotePort;

    // Flag that is used to stop the run() method
    private boolean runScan;

    // Flag that is used to prevent multiple threads to execute the run method concurrently
    private final AtomicBoolean busy = new AtomicBoolean(false);

    // Thread in which the run() method of the AlertClientTcp object is executed
    private Thread scanThread = null;

    // Listeners
    private List<AlertDeviceScanListener> listenerList;

    /**
     * Creates a new runnable that scans a range of network addresses in order to detect alert
     * service nodes.
     *
     * @param networkAdrStr Address of the network address to be scanned without the last octet.
     * @param nodeAdrFirst First node address to be scanned. The node address is appended to the
     *                     network address.
     * @param nodeAdrLast Last node address to be scanned. The node address is appended to the
     *      *             network address.
     * @param alertRemotePort Remote port at which the alert service is offered by
     *                        the alert devices.
     */
    public AlertDeviceScanTcp(String networkAdrStr,
                              int nodeAdrFirst, int nodeAdrLast,
                              int alertRemotePort) {
        this.networkAdrStr = networkAdrStr;
        this.nodeAdrFirst = nodeAdrFirst;
        this.nodeAdrLast = nodeAdrLast;
        this.alertRemotePort = alertRemotePort;

        listenerList = new LinkedList<>();
    }

    /**
     * Returns the state of the scan process.
     *
     * @return True, if the scan is active.
     */
    public boolean isRunning() {
        return runScan;
    }

    /**
     * Stops the running scan process.
     */
    public void stopScan() {

        // Tell the run method to stop
        runScan = false;

        // Interrupt the thread in case it is sleeping
        if (scanThread != null) {
            scanThread.interrupt();
        }
    }

    /**
     * Connects to the specified address to determine if an alert device is present.
     *
     * @return True, if connection to the alert device was successful.
     */
    private AlertDeviceModel scanAddress(String deviceAddrStr, int devicePort) {

        // Client socket for communicating with the alert device
        Socket testSocket;

        // Output stream to alert device
        OutputStream testOut;

        // Input stream from alert device
        InputStream testIn;

        InetAddress deviceAddr;

        // Object to be returned
        AlertDeviceModel device = null;

        try {
            Log.i(TAG, "Testing for alert device at " + deviceAddrStr + ":" + devicePort);

            // Create InetAddress to connect to
            deviceAddr = InetAddress.getByName(deviceAddrStr);

            // Create a socket and connect to the alert device using the specified address and port
            testSocket = new Socket();

            SocketAddress socketAddr = new InetSocketAddress(deviceAddr, devicePort);

            testSocket.connect(socketAddr, TIME_CONNECT_MAX);

            Log.i( TAG, "Successfully connected to device: "
                    + testSocket.getRemoteSocketAddress() );

            // Get input stream from server
            testIn = testSocket.getInputStream();

            // Get output stream to server
            testOut = testSocket.getOutputStream();

            // Request device id
            testOut.write(AlertClientTcp.CMD_ID_REQUEST);
            testOut.flush();

            try {
                Thread.currentThread().sleep(500);
            }
            catch (InterruptedException e) {

            }

            // Number of input values in input buffer
            int numRxAvailable = testIn.available();

            // Read response from device
            if (numRxAvailable == AlertClientTcp.ID_NUM_BYTES) {

                byte[] idBytes = new byte[AlertClientTcp.ID_NUM_BYTES];

                int numRxRead = testIn.read(idBytes, 0, AlertClientTcp.ID_NUM_BYTES);

                if (numRxRead != AlertClientTcp.ID_NUM_BYTES) {
                    throw new IOException("Failed reading device id.");
                }

                long idLong = 0;

                for (int i = 0; i < AlertClientTcp.ID_NUM_BYTES; i++) {
                    int val = ((int) idBytes[i]) & 0xFF;
                    idLong = (idLong << 8) + val;
                }

                String idStr = Long.toHexString(idLong);

                Log.i(TAG, "Device id: " + idStr);

                // Create an alert device object with the detected address, the port, and the id
                device = new AlertDeviceModel();
                device.setAddress(deviceAddrStr);
                device.setPort(devicePort);
                device.setId(idStr);
            }
            else {
                Log.i(TAG, "Device failed to provide id.");
            }

            testSocket.close();
        }
        catch (UnknownHostException e) {
            Log.i(TAG, "Could not find a device at " + deviceAddrStr + ":" + devicePort);
        }
        catch (SocketTimeoutException e) {
            Log.i(TAG, "Timeout while connecting to device " + deviceAddrStr
                    + " at port " + devicePort);
        }
        catch (IOException e) {
            Log.i(TAG, "IOException while connecting to device " + deviceAddrStr
                    + " at port " + devicePort);
        }

        // Return connection state
        return device;
    }


    /**
     * When an object implementing interface <code>Runnable</code> is used
     * to create a thread, starting the thread causes the object's
     * <code>run</code> method to be called in that separately executing
     * thread.
     * <p>
     * The general contract of the method <code>run</code> is that it may
     * take any action whatsoever.
     *
     * @see Thread#run()
     */
    @Override
    public void run() {
        // Set Thread priority to background
        android.os.Process.setThreadPriority(android.os.Process.THREAD_PRIORITY_BACKGROUND);

        // When this runnable is already running wait until the thread has finished
        while ( !busy.compareAndSet(false, true) ) {
            try {
                synchronized (busy) {
                    busy.wait();
                }
            } catch (InterruptedException e) {
                // Wakeup from sleep
            }
        }

        // Store the current Thread so that the shutdown method can interrupt it
        scanThread = Thread.currentThread();

        try {
            int adrNodeNext = nodeAdrFirst;

            // Set run flag
            runScan = true;

            // Repeat as long as the flag is true:
            while (runScan) {
                String scanAdrStr = networkAdrStr + "." + adrNodeNext;

                AlertDeviceModel device = scanAddress(scanAdrStr, alertRemotePort);

                if (device != null) {
                    Log.i(TAG, "Found alert node at address " + scanAdrStr);

                    // Notify listeners about the new device
                    for (AlertDeviceScanListener listener:listenerList) {
                        listener.onDeviceFound(device);
                    }
                }

                if (adrNodeNext == nodeAdrLast) {
                    runScan = false;
                }
                else {
                    adrNodeNext += 1;
                }
            }
        }
        catch (Exception e) {
            Log.e(TAG, "Exception while scanning for alert devices.", e);
        }
        finally {
            // Clean everything up before leaving the run() method
            Log.i(TAG, "Finished scanning for alert devices.");

            // Notify listeners
            for (AlertDeviceScanListener listener:listenerList) {
                listener.onScanFinished();
            }

            // Set the stored Thread of AlertClientTcp to null
            scanThread = null;

            // Set busy flag to false after scan has finished or been aborted
            synchronized (busy) {
                busy.set(false);
                busy.notify();
            }
        }

    }

    /**
     * Registers a listener that is informed about scan events during the scan process.
     *
     * @param listener Listener object to be informed about scan events.
     */
    public void addListener(AlertDeviceScanListener listener) {
        if ( !listenerList.contains(listener) ) {
            listenerList.add(listener);
        }
    }

    /**
     * Removes a registered listener object.
     *
     * @param listener Listener object to be informed about scan events.
     */
    public void removeListener(AlertDeviceScanListener listener) {
        listenerList.remove(listener);
    }

    /**
     * Interface that must be implemented by objects listening to scan events.
     */
    public interface AlertDeviceScanListener {

        /**
         * This method is called when the scan process has detected an alert device.
         *
         * @param device Object carrying the remote address and port of the detected device.
         */
        void onDeviceFound(AlertDeviceModel device);

        /**
         * This method is called when the scan process has finished.
         */
        void onScanFinished();

    }
}